//172. Factorial Trailing Zeroes

//Given an integer n, return the number of trailing zeroes in n!.
//Note: Your solution should be in logarithmic time complexity.

public class Solution {
    public int trailingZeroes(int n) {
        if(n == 0) return 0;
        return n / 5 + trailingZeroes(n / 5);
    }
}
------------------

//26. Remove Duplicates from Sorted Array

//Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.
//Do not allocate extra space for another array, you must do this in place with constant memory.

public class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length == 1) return 1;
        int i = 1;
        int j = 1;
        for(i = 1; i < nums.length; i++){
            if(nums[i] != nums[i-1]){
                nums[j] = nums[i];
                j++;
            }
        }
        return j;
    }
}
--------------------

//141. Linked List Cycle

//Given a linked list, determine if it has a cycle in it.
//Follow up: Can you solve it without using extra space?

/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null) return false;
        ListNode fast = head;
        ListNode slow = head;
        while(fast.next != null && fast.next.next != null){
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow) return true;
        }
        return false;
    }
}
------------------

//9. Palindrome Number

//Determine whether an integer is a palindrome. Do this without extra space.

public class Solution {
    public boolean isPalindrome(int x) {
        char[] ch = Integer.toString(x).toCharArray();
        int i = 0;
        int j = ch.length - 1;
        while(i < j){
            if(ch[i] != ch[j]) return false;
            i++;
            j--;
        }
        return true;
    }
}
----------------
public class Solution {
    public boolean isPalindrome(int x) {
        int xx = Math.abs(x);
        int rev = 0;
        while(xx > 0){
            rev = xx % 10 + rev * 10;
            xx = xx / 10;
        }
        return rev == x;
    }
}
-------------------

//374. Guess Number Higher or Lower

//We are playing the Guess Game. The game is as follows:
//I pick a number from 1 to n. You have to guess which number I picked.
//Every time you guess wrong, I'll tell you whether the number is higher or lower.
//You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):
//-1 : My number is lower
//1 : My number is higher
//0 : Congrats! You got it!

/* The guess API is defined in the parent class GuessGame.
   @param num, your guess
   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
      int guess(int num); */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int i = 1;
        int j = n;
        while(i < j){
            int mid = i + (j - i) / 2;
            if(guess(mid) == 0) return mid;
            else if(guess(mid) == -1) j = mid;
            else i = mid + 1;
        }
        return i;
    }
}
----------------

//38. Count and Say

//The count-and-say sequence is the sequence of integers with the first five terms as following:
//1.     1
//2.     11
//3.     21
//4.     1211
//5.     111221
//1 is read off as "one 1" or 11.
//11 is read off as "two 1s" or 21.
//21 is read off as "one 2, then one 1" or 1211.
//Given an integer n, generate the nth term of the count-and-say sequence.
//Note: Each term of the sequence of integers will be represented as a string.

public class Solution {
    public String countAndSay(int n) {
        if(n < 1) return "";
        StringBuilder curr = new StringBuilder("1");
        StringBuilder prev = new StringBuilder();
        for(int i = 1; i < n; i++){
            prev = curr;
            curr = new StringBuilder();
            int count = 1;
            char say = prev.charAt(0);
            for(int j = 1; j < prev.length(); j++){
                if(prev.charAt(j) == say){
                    count++;
                }
                else{
                    curr.append(count).append(say);
                    say = prev.charAt(j);
                    count = 1;
                }
            }
            curr.append(count).append(say);
        }
        return curr.toString();
    }
}
-------------------

//112. Path Sum

//Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null) return false;
        calSum(root, 0);
        if(set.contains(sum)) return true;
        return false;
    }
    
    private Set<Integer> set = new HashSet<>();
    
    private void calSum(TreeNode root, int n){
        if(root.left == null && root.right == null){
            n += root.val;
            set.add(n);
        }
        if(root.left != null){
            calSum(root.left, n + root.val);
        }
        if(root.right != null){
            calSum(root.right, n + root.val);
        }
    }
}
----------------
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null) return false;
        if(root.left == null && root.right == null && root.val == sum) return true;
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
}
--------------

//507. Perfect Number

//We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself.
//Now, given an integer n, write a function that returns true when it is a perfect number and false when it is not.

    public boolean checkPerfectNumber(int num) {
        if(num == 1) return false;
        int sum = 0;
        for(int i = 2; i <= Math.sqrt(num); i++){
            if(num % i == 0){
                sum += i;
                if(num / i != i) sum += num / i;
            }
        }
        sum++;
        return sum == num;
    }
}
------------------

//205. Isomorphic Strings

//Given two strings s and t, determine if they are isomorphic.
//Two strings are isomorphic if the characters in s can be replaced to get t.
//All occurrences of a character must be replaced with another character while preserving the order of characters. 
//No two characters may map to the same character but a character may map to itself.

public class Solution {
    public boolean isIsomorphic(String s, String t) {
        if(s.length() != t.length()) return false;
        Map<Character, Character> map = new HashMap<>();
        int i = 0;
        while(i < s.length()){
            if(map.get(s.charAt(i)) != null && map.get(s.charAt(i)) != t.charAt(i)) return false;
            map.put(s.charAt(i), t.charAt(i));
            i++;
        }
        Set<Character> set = new HashSet<>();
        for(char val : map.values()){
            if(set.contains(val)) return false;
            set.add(val);
        }
        return true;
    }
}
-----------------

//438. Find All Anagrams in a String

//Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.
//Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.
//The order of output does not matter.

public class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> ret = new ArrayList<Integer>();
        if(s == null || s.length() == 0 || p == null || p.length() == 0) return ret;
        int[] count = new int[256];
        for(char c : p.toCharArray()){
            count[c]++;
        }
        int left = 0;
        int right = 0;
        int len = p.length();
        while(right < s.length()){
            if(count[s.charAt(right++)]-- >= 1){
                len--;
            }
            if(len == 0){
                ret.add(left);
            }
            if(right - left == p.length() && count[s.charAt(left++)]++ >= 0){
                len++;
            }
        }
        return ret;
    }
}
-----------------

//1. Two Sum

//Given an array of integers, return indices of the two numbers such that they add up to a specific target.
//You may assume that each input would have exactly one solution, and you may not use the same element twice.

public class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int[] ret = new int[2];
        for(int i = 0; i < nums.length; i++){
            if(map.containsKey(target-nums[i])){
                ret[0] = map.get(target-nums[i]);
                ret[1] = i;
            }
            else{
                map.put(nums[i], i);
            }
        }
        return ret;
    }
}
-------------------

//20. Valid Parentheses

//Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
//The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.

public class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<Character>();
        for(char c : s.toCharArray()){
            if(c == '('){
                stack.push(')');
            }
            else if(c == '{'){
                stack.push('}');
            }
            else if(c == '['){
                stack.push(']');
            }
            else if(stack.isEmpty() || c != stack.pop()) return false;
        }
        return stack.isEmpty();
    }
}
----------------

//111. Minimum Depth of Binary Tree

//Given a binary tree, find its minimum depth.
//The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        count(root, 1);
        return min;
    }
    
    private int min = Integer.MAX_VALUE;
    
    private void count(TreeNode root, int d){
        if(root.left == null && root.right == null){
            min = Math.min(d, min);
        }
        if(root.left != null){
            count(root.left, d + 1);
        }
        if(root.right != null){
            count(root.right, d + 1);
        }
    }
}
-----------------
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        int left = minDepth(root.left);
        int right = minDepth(root.right);
        return (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;
    }
}
-------------------

//290. Word Pattern

//Given a pattern and a string str, find if str follows the same pattern.
//Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.
//You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.

public class Solution {
    public boolean wordPattern(String pattern, String str) {
        String[] words = str.split(" ");
        if(pattern.length() != words.length) return false;
        Map<Character, String> map = new HashMap<Character, String>();
        for(int i = 0; i < pattern.length(); i++){
            if(map.get(pattern.charAt(i)) != null && !(map.get(pattern.charAt(i))).equals(words[i])) return false;
            map.put(pattern.charAt(i), words[i]);
        }
        Set<String> set = new HashSet<String>();
        for(String val : map.values()){
            if(set.contains(val)) return false;
            set.add(val);
        }
        return true;
    }
}
-------------------
public class Solution {
    public boolean wordPattern(String pattern, String str) {
        String[] words = str.split(" ");
        if(pattern.length() != words.length) return false;
        Map map = new HashMap();
        for(Integer i = 0; i < pattern.length(); i++){
            if(map.put(pattern.charAt(i), i) != map.put(words[i], i)) return false;
        }
        return true;
    }
}
------------------

//225. Implement Stack using Queues

//Implement the following operations of a stack using queues.
//push(x) -- Push element x onto stack.
//pop() -- Removes the element on top of the stack.
//top() -- Get the top element.
//empty() -- Return whether the stack is empty.
//Notes: You must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid.
//Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.
//You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).

public class MyStack {

    /** Initialize your data structure here. */
    public MyStack() {
        
    }
    
    Queue<Integer> q = new LinkedList<Integer>();
    
    /** Push element x onto stack. */
    public void push(int x) {
        q.add(x);
        for(int i = 0;i < q.size()-1; i++){
            q.add(q.poll());
        }
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        return q.poll();
    }
    
    /** Get the top element. */
    public int top() {
        return q.peek();
    }
    
    /** Returns whether the stack is empty. */
    public boolean empty() {
        return q.isEmpty();
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */
 --------------------
 
//234. Palindrome Linked List
 
//Given a singly linked list, determine if it is a palindrome.
//Follow up: Could you do it in O(n) time and O(1) space?

**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
        }
        if(fast != null){
            slow = slow.next;
        }
        slow = reverse(slow);
        fast = head;
        while(slow != null){
            if(slow.val != fast.val) return false;
            slow = slow.next;
            fast = fast.next;
        }
        return true;
    }
    
    private ListNode reverse(ListNode head){
        ListNode prev = null;
        while(head != null){
            ListNode next = head.next;
            head.next = prev;
            prev = head;
            head = next;
        }
        return prev;
    }
}
------------------

//219. Contains Duplicate II

//Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that 
//nums[i] = nums[j] and the absolute difference between i and j is at most k.

public class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        for(int i = 0; i < nums.length; i++){
            if(map.get(nums[i]) != null){
                if(Math.abs(map.get(nums[i]) - i) <= k) return true;
            }
            map.put(nums[i], i);
        }
        return false;
    }
}
-----------------
public class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Set<Integer> set = new HashSet<Integer>();
        for(int i = 0; i < nums.length; i++){
            if(i > k){
                set.remove(nums[i-k-1]);
            }
            if(set.contains(nums[i])) return true;
            set.add(nums[i]);
        }
        return false;
    }
}
----------------------

//203. Remove Linked List Elements

//Remove all elements from a linked list of integers that have value val.

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head == null) return null;
        ListNode node = head;
        while(node != null && node.next != null){
            if(node.next.val == val){
                node.next = node.next.next;
            }
            else{
                node = node.next;
            }
        }
        return head.val == val ? head.next : head;
    }
}
-------------------
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head == null) return null;
        head.next = removeElements(head.next, val);
        return head.val == val ? head.next : head;
    }
}
------------------

//88. Merge Sorted Array

//Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.
//Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. 
//The number of elements initialized in nums1 and nums2 are m and n respectively.

public class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1;
        int j = n - 1;
        int k = m + n - 1;
        while(i >= 0 && j >= 0){
            if(nums1[i] > nums2[j]){
                nums1[k--] = nums1[i--];
            }
            else{
                nums1[k--] = nums2[j--];
            }
        }
        while(j >= 0){
            nums1[k--] = nums2[j--];
        }
    }
}
-----------------

//67. Add Binary

//Given two binary strings, return their sum (also a binary string).

public class Solution {
    public String addBinary(String a, String b) {
        StringBuilder sb = new StringBuilder();
        int i = a.length() - 1;
        int j = b.length() - 1;
        int c = 0;
        while(i >= 0 || j >= 0){
            if(i >= 0) c += a.charAt(i--) - '0';
            if(j >= 0) c += b.charAt(j--) - '0';
            sb.append(c % 2);
            c /= 2;
        }
        if(c != 0) sb.append(c);
        return sb.reverse().toString();
    }
}
---------------

//58. Length of Last Word

//Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.
//If the last word does not exist, return 0.
//Note: A word is defined as a character sequence consists of non-space characters only.

public class Solution {
    public int lengthOfLastWord(String s) {
        s = s.trim();
        int length = 0;
        char[] s_char = s.toCharArray();
        for(int i = s.length() - 1; i >= 0; i--){
            if(s_char[i] != ' ') length++;
            else break;
        }
        return length;
    }
}
-----------------
public class Solution {
    public int lengthOfLastWord(String s) {
        return s.trim().length() - 1 - s.trim().lastIndexOf(' ');
    }
}
----------------

//14. Longest Common Prefix

//Write a function to find the longest common prefix string amongst an array of strings.

public class Solution {
    public String longestCommonPrefix(String[] strs) {
        if(strs.length == 0) return "";
        //if(strs.length == 1) return strs[0];
        int i = 0;
        for(i = 0; i < strs[0].length(); i++){
            for(int j = 0; j < strs.length; j++){
                if(i < strs[j].length()){
                    if(strs[0].charAt(i) != strs[j].charAt(i)) return strs[0].substring(0, i);
                }
                else return strs[j];
            }
        }
        return strs[0];
    }
}
-----------------

//605. Can Place Flowers

//Suppose you have a long flowerbed in which some of the plots are planted and some are not. 
//However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.
//Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, 
//return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.

public class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        for(int i = 0; i < flowerbed.length; i++){
            if(flowerbed[i] == 0){
                int prev = (i == 0) ? 0 : flowerbed[i-1];
                int next = (i == flowerbed.length-1) ? 0 : flowerbed[i+1];
                if(prev == 0 && next == 0){
                    flowerbed[i] = 1;
                    n--;
                }
            }
        }
        return n <= 0;
    }
}
-------------------

//160. Intersection of Two Linked Lists

//Write a program to find the node at which the intersection of two singly linked lists begins.
//Notes:
//If the two linked lists have no intersection at all, return null.
//The linked lists must retain their original structure after the function returns.
//You may assume there are no cycles anywhere in the entire linked structure.
//Your code should preferably run in O(n) time and use only O(1) memory.

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA == null || headB == null) return null;
        ListNode a = headA;
        ListNode b = headB;
        while(a != b){
            a = (a == null) ? headB : a.next;
            b = (b == null) ? headA : b.next;
        }
        return a;
    }
}
------------------

//624. Maximum Distance in Arrays

//Given m arrays, and each array is sorted in ascending order. 
//Now you can pick up two integers from two different arrays (each array picks one) and calculate the distance. 
//We define the distance between two integers a and b to be their absolute difference |a-b|. 
//Your task is to find the maximum distance.

public class Solution {
    public int maxDistance(List<List<Integer>> arrays) {
        int min = arrays.get(0).get(0);
        int max = arrays.get(0).get(arrays.get(0).size()-1);
        int dis = 0;
        for(int i = 1; i < arrays.size(); i++){
            dis = Math.max(dis, Math.abs(min - arrays.get(i).get(arrays.get(i).size()-1)));
            dis = Math.max(dis, Math.abs(max - arrays.get(i).get(0)));
            min = Math.min(min, arrays.get(i).get(0));
            max = Math.max(max, arrays.get(i).get(arrays.get(i).size()-1));
        }
        return dis;
    }
}
-----------------

//400. Nth Digit

//Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...
//Note: n is positive and will fit within the range of a 32-bit signed integer (n < 231).

public class Solution {
    public int findNthDigit(int n) {
        int start = 1;
        long count = 9;
        int len = 1;
        while(count * len < n){
            n -= count * len;
            start *= 10;
            len += 1;
            count *= 10;
        }
        start += (n-1) / len;
        char ch = Integer.toString(start).charAt((n-1) % len);
        return Character.getNumericValue(ch);
    }
}
--------------

//581. Shortest Unsorted Continuous Subarray

//Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, 
//then the whole array will be sorted in ascending order, too.
//You need to find the shortest such subarray and output its length.

public class Solution {
    public int findUnsortedSubarray(int[] nums) {
        if(nums == null || nums.length == 0) return 0;
        int[] n = new int[nums.length];
        for(int i = 0; i < nums.length; i++){
            n[i] = nums[i];
        }
        Arrays.sort(nums);
        int start = 0;
        int end = -1;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] != n[i]){
                start = i;
                break;
            }
        }
        for(int i = nums.length - 1; i >= 0; i--){
            if(nums[i] != n[i]){
                end = i;
                break;
            }
        }
        return end - start + 1;
    }
}
-----------------
public class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int start = 0;
        int end = -1;
        int min = nums[nums.length-1];
        int max = nums[0];
        for(int i = 0; i < nums.length; i++){
            max = Math.max(max, nums[i]);
            min = Math.min(min, nums[nums.length-1-i]);
            if(max > nums[i]) end = i;
            if(min < nums[nums.length-1-i]) start = nums.length-1-i;
        }
        return end - start + 1;
    }
}
-----------------

//475. Heaters

//Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses.
//Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.
//So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.

public class Solution {
    public int findRadius(int[] houses, int[] heaters) {
        Arrays.sort(houses);
        Arrays.sort(heaters);
        int i = 0;
        int ret = 0;
        for(int house : houses){
            while(i < heaters.length - 1 && heaters[i] + heaters[i+1] <= house * 2) i++;
            ret = Math.max(ret, Math.abs(heaters[i] - house));
        }
        return ret;
    }
}
---------------

//190. Reverse Bits

//Reverse bits of a given 32 bits unsigned integer.
//For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), 
//return 964176192 (represented in binary as 00111001011110000010100101000000).

public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int ret = 0;
        for(int i = 0; i < 32; i++){
            ret += n & 1;
            n >>>= 1;
            if(i < 31){
                ret <<= 1;
            }
        }
        return ret;
    }
}
---------------

//633. Sum of Square Numbers

//Given a non-negative integer c, your task is to decide whether there're two integers a and b such that a2 + b2 = c.

public class Solution {
    public boolean judgeSquareSum(int c) {
        int n = (int) Math.sqrt(c);
        for(int i = 0; i <= n; i++){
            int a = (int) Math.sqrt(c - i * i);
            if(a * a == c - i * i) return true;
        }
        return false;
    }
}
----------------
public class Solution {
    public boolean judgeSquareSum(int c) {
        int n = (int) Math.sqrt(c);
        int i = 0;
        int j = n;
        while(i <= j){
            if(i * i + j * j < c) i++;
            if(i * i + j * j > c) j--;
            if(i * i + j * j == c) return true;
        }
        return false;
    }
}
------------------

//303. Range Sum Query - Immutable

//Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.
//Note:
//You may assume that the array does not change.
//There are many calls to sumRange function.

public class NumArray {
    private int[] sums;

    public NumArray(int[] nums) {
        if(nums != null && nums.length > 0){
            sums = new int[nums.length];
            sums[0] = nums[0];
            for(int i = 1; i < nums.length; i++){
                sums[i] = nums[i] + sums[i-1];
            }
        }
    }
    
    public int sumRange(int i, int j) {
        if(i == 0){
            return sums[j];
        }
        else{
            return sums[j] - sums[i-1];
        }
    }
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * int param_1 = obj.sumRange(i,j);
 */
 -----------------
 
//155. Min Stack
 
//Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
//push(x) -- Push element x onto stack.
//pop() -- Removes the element on top of the stack.
//top() -- Get the top element.
//getMin() -- Retrieve the minimum element in the stack.

public class MinStack {
    private Stack<Long> stack = new Stack<Long>();
    private long min;

    /** initialize your data structure here. */
    public MinStack() {
        
    }
    
    public void push(int x) {
        if(stack.isEmpty()){
            stack.push(0L);
            min = x;
        }
        else{
            stack.push(x-min);
            if(x-min < 0){
                min = x;
            }
        }
    }
    
    public void pop() {
        if(stack.isEmpty()) return;
        long pop = stack.pop();
        if(pop < 0){
            min = min - pop;
        }
    }
    
    public int top() {
        long top = stack.peek();
        if(top < 0) return (int) min;
        else return (int) (top + min);
    }
    
    public int getMin() {
        return (int) min;
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
 -------------
 public class MinStack {
    private Stack<Integer> stack = new Stack<Integer>();
    private int min = Integer.MAX_VALUE;

    /** initialize your data structure here. */
    public MinStack() {
        
    }
    
    public void push(int x) {
        if(x <= min){
            stack.push(min);
            min = x;
        }
        stack.push(x);
    }
    
    public void pop() {
        if(stack.pop() == min) min = stack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return min;
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
 -------------
 
//532. K-diff Pairs in an Array
 
//Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. 
//Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.

public class Solution {
    public int findPairs(int[] nums, int k) {
        if(nums == null || nums.length <= 1 || k < 0) return 0;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int count = 0;
        for(int num : nums){
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        for(int key : map.keySet()){
            if(k == 0){
                if(map.get(key) >= 2) count++;
            }
            else{
                if(map.containsKey(key + k)) count++;
            }
        }
        return count;
    }
}
----------------

//657. Judge Route Circle

//Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place.
//The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). 
//The output should be true or false representing whether the robot makes a circle.

class Solution {
    public boolean judgeCircle(String moves) {
        int x = 0;
        int y = 0;
        for(char ch : moves.toCharArray()){
            if(ch == 'L') x--;
            if(ch == 'R') x++;
            if(ch == 'U') y++;
            if(ch == 'D') y--;
        }
        return x == 0 && y == 0;
    }
}
--------------------

//637. Average of Levels in Binary Tree

//Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
        List<Double> ret = new ArrayList<>();
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){
            int n = q.size();
            double sum = 0.0;
            for(int i = 0; i < n; i++){
                TreeNode node = q.poll();
                if(node.left != null) q.add(node.left);
                if(node.right != null) q.add(node.right);
                sum += node.val;
            }
            ret.add(sum/n);
        }
        return ret;
    }
}
------------------

//653. Two Sum IV - Input is a BST

//Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean findTarget(TreeNode root, int k) {
        if(root == null) return false;
        HashSet<Integer> set = new HashSet<>();
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){
            TreeNode node = q.poll();
            if(set.contains(k - node.val)) return true;
            if(node.left != null) q.add(node.left);
            if(node.right != null) q.add(node.right);
            set.add(node.val);
        }
        return false;
    }
}
----------------

//538. Convert BST to Greater Tree

//Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST 
//is changed to the original key plus sum of all keys greater than the original key in BST.

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    private int sum = 0;
    
    public TreeNode convertBST(TreeNode root) {
        addValue(root);
        return root;
    }
    
    private void addValue(TreeNode node){
        if(node == null) return;
        addValue(node.right);
        node.val += sum;
        sum = node.val;
        addValue(node.left);
    }
}
------------------

//628. Maximum Product of Three Numbers

//Given an integer array, find three numbers whose product is maximum and output the maximum product.

class Solution {
    public int maximumProduct(int[] nums) {
        int max1 = Integer.MIN_VALUE;
        int max2 = Integer.MIN_VALUE;
        int max3 = Integer.MIN_VALUE;
        int min1 = Integer.MAX_VALUE;
        int min2 = Integer.MAX_VALUE;
        
        for(int num : nums){
            if(num > max1){
                max3 = max2;
                max2 = max1;
                max1 = num;
            }else if(num > max2){
                max3 = max2;
                max2 = num;
            }else if(num > max3){
                max3 = num;
            }
            
            if(num < min1){
                min2 = min1;
                min1 = num;
            }else if(num < min2){
                min2 = num;
            }
        }
        return Math.max(max1 * max2 * max3, min1 * min2 * max1);
    }
}
-----------------

//645. Set Mismatch

//The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, 
//one of the numbers in the set got duplicated to another number in the set, 
//which results in repetition of one number and loss of another number.
//Given an array nums representing the data status of this set after the error. 
//Your task is to firstly find the number occurs twice and then find the number that is missing. 
//Return them in the form of an array.

class Solution {
    public int[] findErrorNums(int[] nums) {
        Arrays.sort(nums);
        int[] ret = new int[2];
        for(int i = 0; i < nums.length-1; i++){
            if(nums[i+1] - nums[i] == 0){
                ret[0] = nums[i];
            }else if(nums[i+1] - nums[i] == 2){
                ret[1] = nums[i] + 1;
            }
        }
        if(ret[1] == 0){
            if(nums[0] != 1){
                ret[1] = 1;
            }else{
                ret[1] = nums[nums.length-1] + 1;
            }
        }
        return ret;
    }
}
----------------------

class Solution {
    public int[] findErrorNums(int[] nums) {
        int n = nums.length;
        int sum = n*(n+1)/2;
        HashSet<Integer> set = new HashSet<>();
        int dup = 0;
        for(int num : nums){
            if(set.contains(num)){
                dup = num;
            }
            set.add(num);
            sum -= num;
        }
        return new int[]{dup, dup+sum};
    }
}
---------------

//643. Maximum Average Subarray I

//Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. 
//And you need to output the maximum average value.

class Solution {
    public double findMaxAverage(int[] nums, int k) {
        double max = 0.0;
        for(int i = 0; i < k; i++){
            max += nums[i];
        }
        double sum = max;
        for(int i = 0; i < nums.length-k; i++){
            sum = sum-nums[i]+nums[i+k];
            max = Math.max(max, sum);
        }
        return max/k;
    }
}
----------------

//28. Implement strStr()

//Implement strStr().
//Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

class Solution {
    public int strStr(String haystack, String needle) {
        if(haystack.length() == 0 && needle.length() == 0) return 0;
        if(needle.length() == 0) return 0;
        char[] h = haystack.toCharArray();
        char[] n = needle.toCharArray();
        int j = 0;
        for(int i = 0; i < h.length; i++){
            if(h[i] == n[j]){
                if(j == n.length-1){
                    return i-j;
                }
                j++;
            }else{
                i = i-j;
                j = 0;
            }
        }
        return -1;
    }
}
-------------------

//414. Third Maximum Number

//Given a non-empty array of integers, return the third maximum number in this array. 
//If it does not exist, return the maximum number. The time complexity must be in O(n).

class Solution {
    public int thirdMax(int[] nums) {
        Integer max1 = null;
        Integer max2 = null;
        Integer max3 = null;
        for(Integer num : nums){
            if(num.equals(max1) || num.equals(max2) || num.equals(max3)) continue;
            if(max1 == null || num > max1){
                max3 = max2;
                max2 = max1;
                max1 = num;
            }else if(max2 == null || num > max2){
                max3 = max2;
                max2 = num;
            }else if(max3 == null || num > max3){
                max3 = num;
            }
        }
        return max3 == null ? max1 : max3;
    }
}
------------------

//69. Sqrt(x)

//Implement int sqrt(int x).
//Compute and return the square root of x.

class Solution {
    public int mySqrt(int x) {
        long r = x;
        while(r*r > x){
            r = (r + x/r)/2;
        }
        return (int)r;
    }
}
----------------

//204. Count Primes

//Count the number of prime numbers less than a non-negative number, n.

class Solution {
    public int countPrimes(int n) {
        int count = 0;
        boolean[] notPrime = new boolean[n];
        for(int i = 2; i < n; i++){
            if(!notPrime[i]){
                count++;
                for(int j = 2; j*i < n; j++){
                    notPrime[i*j] = true;
                }
            }
        }
        return count;
    }
}
----------------

//125. Valid Palindrome

//Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

class Solution {
    public boolean isPalindrome(String s) {
        if(s.length() == 0) return true;
        int head = 0;
        int tail = s.length()-1;
        while(head < tail){
            char chHead = s.charAt(head);
            char chTail = s.charAt(tail);
            if(!Character.isLetterOrDigit(s.charAt(head))){
                head++;
            }else if(!Character.isLetterOrDigit(s.charAt(tail))){
                tail--;
            }else if(Character.toLowerCase(s.charAt(head)) != Character.toLowerCase(s.charAt(tail))){
                return false;
            }else{
                head++;
                tail--;
            }
        }
        return true;
    }
}
--------------------

class Solution {
    public boolean isPalindrome(String s) {
        String str = s.replaceAll("[^A-Za-z0-9]", "").toLowerCase();
        String reverse = new StringBuffer(str).reverse().toString();
        return reverse.equals(str);
    }
}
--------------------

//168. Excel Sheet Column Title

//Given a positive integer, return its corresponding column title as appear in an Excel sheet.

class Solution {
    public String convertToTitle(int n) {
        StringBuilder sb = new StringBuilder();
        int r = 0;
        while(n > 0){
            n--;
            r = n % 26;
            n /= 26;
            sb.append((char)('A'+r));
        }
        return sb.reverse().toString();
    }
}
-----------------

//278. First Bad Version

//You are a product manager and currently leading a team to develop a new product. 
//Unfortunately, the latest version of your product fails the quality check. 
//Since each version is developed based on the previous version, all the versions after a bad version are also bad.
//Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.
//You are given an API bool isBadVersion(version) which will return whether version is bad. 
//Implement a function to find the first bad version. You should minimize the number of calls to the API.

/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int head = 1;
        int tail = n;
        
        while(head < tail){
            int pnt = head + (tail - head) / 2;
            if(isBadVersion(pnt) == false){
                head = pnt + 1;
            }else if(isBadVersion(pnt) == true){
                tail = pnt;
            }
        }
        return head;
    }
}
---------------

//189. Rotate Array

//Rotate an array of n elements to the right by k steps.
//For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].

class Solution {
    public void rotate(int[] nums, int k) {
        int step = k % nums.length;
        reverse(nums, 0, nums.length-1);
        reverse(nums, 0, step-1);
        reverse(nums, step, nums.length-1);
    }
    
    private void reverse(int[] nums, int start, int end){
        while(start < end){
            int tmp = nums[start];
            nums[start] = nums[end];
            nums[end] = tmp;
            start++;
            end--;
        }
    }
}
----------------

//7. Reverse Integer

//Reverse digits of an integer.
//Example1: x = 123, return 321
//Example2: x = -123, return -321

class Solution {
    public int reverse(int x) {
        int ret = 0;
        while(x != 0){
            int r = x % 10;
            int newRet = ret * 10 + r;
            if((newRet-r)/10 != ret) return 0;
            ret = newRet;
            x /= 10;
        }
        return ret;
    }
}
------------------

//479. Largest Palindrome Product

//Find the largest palindrome made from the product of two n-digit numbers.
//Since the result could be very large, you should return the largest palindrome mod 1337.
//Example:
//Input: 2
//Output: 987
//Explanation: 99 x 91 = 9009, 9009 % 1337 = 987
//Note: The range of n is [1,8].

class Solution {
    public int largestPalindrome(int n) {
        if(n == 1) return 9;
        int mod = (int)Math.pow(10, n);
        int max = mod - 1;
        long pro = (long)max * (long)max;
        int left = (int)(pro/mod - 1);
        pro = (long)left * (long)mod + (long)reverse(left);
        while(left >= mod/10){
            for(int i = max; i > pro/max; i--){
                if(pro % i == 0) return (int)(pro%1337);
            }
            left--;
            pro = (long)left * (long)mod + (long)reverse(left);
        }
        return (int)(pro%1337);
    }
    
    private int reverse(int num){
        int ret = 0;
        while(num != 0){
            ret = ret*10+num%10;
            num /= 10;
        }
        return ret;
    }
}
--------------------

//661. Image Smoother

//Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to 
//make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself. 
//If a cell has less than 8 surrounding cells, then use as many as you can.

class Solution {
    public int[][] imageSmoother(int[][] M) {
        if(M == null) return null;
        int rows = M.length;
        if(rows == 0) return new int[0][];
        int cols = M[0].length;
        int[][] ret = new int[rows][cols];
        for(int row = 0; row < rows; row++){
            for(int col = 0; col < cols; col++){
                int count = 0;
                int sum = 0;
                for(int inR : new int[]{-1, 0, 1}){
                    for(int inC : new int[]{-1, 0, 1}){
                        if(isValid(inR+row, inC+col, rows, cols)){
                            count++;
                            sum += M[inR+row][inC+col];
                        }
                    }
                }
                ret[row][col] = sum / count;
            }
        }
        return ret;
    }
    
    private boolean isValid(int r, int c, int rows, int cols){
        return r >= 0 && r < rows && c >= 0 && c < cols;
    }
}
-----------------
































